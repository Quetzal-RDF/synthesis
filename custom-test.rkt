#lang rosette

(require "custom.rkt")
(require "expression-lexer.rkt")
(require "interp-enumerate.rkt")
(require "utils.rkt")
(require "parse.rkt")



(define-symbolic s1 string?)

(define-symbolic i1 integer?)
(define-symbolic i2 integer?)
(define-symbolic i3 integer?)
(define-symbolic i4 integer?)
(define-symbolic i5 integer?)


(define (test1)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("i2" "*" "i3")))
         (fs (test-custom stuff columns))
         (result (solve (assert (for/fold ([f #t])
                                          ([e (cadar fs)])
                                  (and f (= e 15)))))))
    (println fs)
    (println result)
    (assert (sat? result))
    (assert (= 15 (evaluate (* i2 i3) result)))))

(define (test1a)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("average" "i2" "*" "i3")))
         (fs (test-custom stuff columns))
         (result (solve (assert (and (> i2 1) (< i2 15) (> i3 1) (< i3 15) (= 15 (caadar fs)))))))
    (println fs)
    (println result)
    (assert (sat? result))))

(define (test2)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("if" "s1" "==" "bad" "then" "i2" "+" "i3")))
         (fs (test-custom stuff columns))
         (result (solve (assert (and (> i2 1) (< i2 17) (> i3 1) (< i3 17) (equal? s1 "bad") (= 17 (caadar fs)))))))
    (println result)
    (println (cddar fs))
    (assert (sat? result))
    (assert (= 17 (evaluate (+ i2 i3) result)))))
  
(define (test2a)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("average" "if" "s1" "==" "bad" "then" "i2" "+" "i3")))
         (fs (test-custom stuff columns))
         (result (solve (assert (= 17 (caadar fs))))))
    (println result)
    (println (apply append (caddar fs)))
    (assert (sat? result))))

(define (test2b)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("average" "if" "s1" "==" "bad" "then" "i2" "+" "i3")))
         (fs (test-custom stuff columns))
         (rows-constraint
          (for/fold ([c #t])
                    ([e (cadar fs)])
            (and c (not (= e 0))))))
    (for/list ([f fs])
      (generate-models (cdr (cadr f)) (cdr (caddr f)) rows-constraint))))

(define (test2c)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("if" "s1" "==" "bad" "then" "i2" "+" "i3")))
         (fs (test-custom stuff columns))
         (rows-constraint
          (for/fold ([c #t])
                    ([e (cadar fs)])
            (and c (not (= e 0))))))
    (for/list ([f fs])
      (generate-models (cdr (cadr f)) (cdr (caddr f)) rows-constraint))))

(define (test3)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("if" "s1" "==" "bad" "then" "i2" "+" "i3")))
        (fs (test-custom stuff columns)))
    (println fs)
    (letrec ((test (lambda (guards ctrls)
                     (if (null? ctrls)                         
                         (let ((result (solve (assert (and guards (= (caadar fs) 17))))))
                           (assert (sat? result))
                           (list result))
                         (append
                          (test (and (car ctrls) guards) (cdr ctrls))
                          (test (and (not (car ctrls)) guards) (cdr ctrls)))))))
      (test #t (car (caddar fs))))))
                          
(define (test4)
  (analyze-custom '("if" "s1" "==" "bad" "then" "i2" "*" "i3") '(50 0) '("s1" "i2" "i3") (list s1 i2 i3) '("bad" 5 10) '("good" 5 10)))

(define (test4a)
  (analyze-custom '("if" "s1" "==" "bad" "then" "i2" "*" "i3" "else" 0) '(50 0) '("s1" "i2" "i3") (list s1 i2 i3) '("bad" 5 10) '("good" 5 10)))

(define (test5)
  (analyze-custom '("if" "s1" "==" "bad" "," "i2" "*" "i3") '(40 50 0) '("s1" "i2" "i3") (list s1 i2 i3) '("bad" 4 10) '("bad" 5 10) '("good" 5 10)))

(define (test6)
   (analyze-custom '("s1" "==" "Committed" "and" "i1" ">=" 25 "," "i3" "-" "(" "i4" "*" "i5" ")")
                   '(5000 0 0)
                   (list s1 i1 i3 i4 i5)
                   '("Committed" 25 10000 100 50) '("Committed" 10 10000 100 50) '("Custom" 25 10000 100 50)))

(define (test7)
   (analyze-custom '("if" "s1" "==" "Committed" "and" "i1" ">=" 25 "," "i3" "-" "(" "i4" "*" "i5" ")")
                   '(5000 6000 0)
                   (list s1 i1 i3 i4 i5)
                   '("Committed" 25 10000 100 50) '("Committed" 25 10000 100 40) '("Custom" 25 10000 100 50)))

(define (test8)
   (analyze-custom '("if" "s1" "==" "Committed" "and" "i1" ">=" 25 "then" "i3" "-" "(" "i4" "*" "i5" ")")
                   '(5000 0 0)
                   (list s1 i1 i3 i4 i5)
                   '("Committed" 25 10000 100 50) '("Committed" 0 10000 100 50) '("Custom" 23 10000 100 50)))

(define (test10)
  (let* ((columns (list s1 i2 i3))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("if" "s1" "==" "bad" "then" "i2" "+" "i3" "else"
                  "if" "s1" "==" "good" "then" "i2" "else"
                  "if" "i3" ">" "i2" "then" "i3")))
         (fs
          (let ((x (test-custom stuff columns)))
            (println "models")
            (println x)
            (println "models")
            x))
         (models (generate-models (cdr (cadar fs)) (cdr (caddar fs)) #t)))
    (to-table (car fs) #t)))
  
(define (test11)
  (let* ((columns  (list s1 i1))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("if" "s1" "is" "foo" "then" "i1" "otherwise" 0)))
         (fs (test-custom stuff columns))
         (rows-constraint
          (for/fold ([c #t])
                    ([e (cadar fs)])
            (and c (not (= e 0))))))
    (to-table (car fs) rows-constraint)))

(define (test12)
  (let* ((columns  (list s1 i1))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("average" "if" "s1" "is" "foo" "then" "i1" "otherwise" 0)))
         (fs (test-custom stuff columns))
         (rows-constraint
          (for/fold ([c #t])
                    ([e (cadar fs)])
            (and c (not (= e 0))))))
    (println fs)
    (to-table (car fs) rows-constraint)))

(define-symbolic A string?)
(define-symbolic B integer?)
(define-symbolic C integer?)
(define-symbolic D integer?)
(define-symbolic E integer?)
(define-symbolic F integer?)
(define-symbolic G integer?)
(define-symbolic H integer?)

(define (test13)
  (let* ((columns  (list A B C D E F G H))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("if" "A" "is" "foo" "then" "B" "otherwise" "0"
                 "+" "if" "A" "is" "bar" "then" "(" "B" "*" "C" ")" "+" "D" "else" "0"
                     "+" "if" "A" "is" "baz" "then" "E" "*" "F" "*" "G" "*" "H")))
         (fs (test-custom stuff columns)))
    (get-rows fs)))

(define colM '((columnName "A" primitiveTypes (3)) (columnName "B" primitiveTypes (1))
               (columnName "C" primitiveTypes (1)) (columnName "D" primitiveTypes (1))(columnName "E" primitiveTypes (1))(columnName "F" primitiveTypes (1))(columnName "G" primitiveTypes (1))(columnName "H" primitiveTypes (1))))

(define (test13a)
  (generate-data
   (lex (open-input-string "if A is foo then B otherwise 0 + if A is bar then (B*C)+D else 0 + if A is baz then E*F*G*H"))
   (list A B C D E F G H)
   (map cadr colM)))

(define-symbolic terms string?)
(define-symbolic price_per_server integer?)
(define-symbolic min_servers integer?)

(define colMetadata '((columnName "terms" primitiveTypes (3)) (columnName "price_per_server" primitiveTypes (1))
               (columnName "min_servers" primitiveTypes (1))))

                         
(define (test13b)
    (generate-data (lex (open-input-string "if terms = Committed then price_per_server else 0 + if terms = Standard then price_per_server * min_servers else 0"))
                       (list terms price_per_server min_servers) (map cadr colMetadata)))

(define (test13c)
  (let* ((columns  (list A B C D E F G H))
         (parse (apply make-parser (map ~a columns)))
         (stuff (parse '("average" "(" "if" "A" "is" "foo" "then" "B" "otherwise" "0" ")"
                 "+" "(" "if" "A" "is" "bar" "then" "(" "B" "*" "C" ")" "+" "D" "else" "0" ")"
                     "+" "(" "if" "A" "is" "baz" "then" "E" "*" "F" "*" "G" "*" "H" ")")))
         (fs (test-custom stuff columns)))
    (for/list ([f fs])
      (list (car f) (generate-models (cdr (cadr f)) (cdr (caddr f)) #t)))))

(define (test14)
   (analyze-custom '("if" "A" "is" "foo" "then" "B" "otherwise" "0"
                        "+" "if" "A" "is" "bar" "then" "(" "B" "*" "C" ")" "+" "D" "else" 0
                             "+" "if" "A" "is" "baz" "then" "E" "*" "F" "*" "G" "*" "H")
                   '(0 1 0 -1 0 -1)
                   (list A B C D E F G H)
                   '("foo" 0 0 0 0 0 0 0) '("foo" 1 0 0 0 0 0 0)
                   '("bar" 0 0 0 0 0 0 0) '("bar" 0 0 -1 0 0 0 0)
                   '("baz" 0 0 0 0 0 0 0) '("baz" 0 0 0 1 1 1 -1)))

(define (test15)
  (let* ((col '((columnName "parent_name" primitiveTypes (3)) (columnName "country" primitiveTypes (3))
               (columnName "coterminating_billing" primitiveTypes (4))
               (columnName "city" primitiveTypes (3))
               (columnName "billing_contact" primitiveTypes (3))
               (columnName "flat_rate" primitiveTypes (1)) (columnName "valid_from" primitiveTypes (2))
               (columnName "sub accounts org id" primitiveTypes (1)) (columnName "billing_address" primitiveTypes (3))
               (columnName "account_owner" primitiveTypes (3)) (columnName "pay_cycle" primitiveTypes (3))
               (columnName "hourly_overage" primitiveTypes (1)) (columnName "expired_status" primitiveTypes (4))
               (columnName "terms" primitiveTypes (3)) (columnName "street" primitiveTypes (3))
               (columnName "valid_to" primitiveTypes (2)) (columnName "is_parent_or_child_account" primitiveTypes (4))
               (columnName "billing_email" primitiveTypes (3)) (columnName "min_servers" primitiveTypes (1))
               (columnName "conversion_date" primitiveTypes (2)) (columnName "customer_tier" primitiveTypes (1))
               (columnName "monthly_overage" primitiveTypes (1)) (columnName "state" primitiveTypes (3))
               (columnName "org_name" primitiveTypes (3)) (columnName "zip" primitiveTypes (1)) (columnName "po_num" primitiveTypes (3))
               (columnName "Unnamed 33" primitiveTypes (-1)) (columnName "pay_method" primitiveTypes (3))
               (columnName "price_per_server" primitiveTypes (1)) (columnName "custom_metrics" primitiveTypes (3))
               (columnName "auto_renew" primitiveTypes (4)) (columnName "org_id" primitiveTypes (1))
               (columnName "parent_account_id" primitiveTypes (1)) (columnName "is_valid" primitiveTypes (4))))
         (symbolics (parse-column-metadata col)))
          (generate-data (lex (open-input-string "if terms = Committed then price_per_server else 0 + if terms = Standard then price_per_server * min_servers else 0"))
                       symbolics (map cadr col))))

(define (test16)
  (let* ((col '((columnName "parent_name" primitiveTypes (3)) (columnName "country" primitiveTypes (3))
               (columnName "city" primitiveTypes (3))
               (columnName "billing_contact" primitiveTypes (3))
               (columnName "flat_rate" primitiveTypes (1)) (columnName "valid_from" primitiveTypes (2))
               (columnName "sub accounts org id" primitiveTypes (1)) (columnName "billing_address" primitiveTypes (3))
               (columnName "account_owner" primitiveTypes (3)) (columnName "pay_cycle" primitiveTypes (3))
               (columnName "hourly_overage" primitiveTypes (1)) (columnName "expired_status" primitiveTypes (4))
               (columnName "terms" primitiveTypes (3)) (columnName "street" primitiveTypes (3))
               (columnName "valid_to" primitiveTypes (2)) (columnName "is_parent_or_child_account" primitiveTypes (4))
               (columnName "billing_email" primitiveTypes (3)) (columnName "min_servers" primitiveTypes (1))
               (columnName "conversion_date" primitiveTypes (2)) (columnName "customer_tier" primitiveTypes (1))
               (columnName "monthly_overage" primitiveTypes (1)) (columnName "state" primitiveTypes (3))
               (columnName "org_name" primitiveTypes (3)) (columnName "zip" primitiveTypes (1)) (columnName "po_num" primitiveTypes (3))
               (columnName "Unnamed 33" primitiveTypes (-1)) (columnName "pay_method" primitiveTypes (3))
               (columnName "price_per_server" primitiveTypes (1)) (columnName "custom_metrics" primitiveTypes (3))
               (columnName "auto_renew" primitiveTypes (4)) (columnName "org_id" primitiveTypes (1))
               (columnName "parent_account_id" primitiveTypes (1)) (columnName "is_valid" primitiveTypes (4))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "if terms is Committed then choose price_per_server otherwise 0 + if terms is Standard then multiply price_per_server and min_servers otherwise 0"))
                   symbolics (map cadr col))))

(define (test17)
  (let* ((col '((columnName "parent_name" primitiveTypes (3)) (columnName "country" primitiveTypes (3))
               (columnName "city" primitiveTypes (3))
               (columnName "billing_contact" primitiveTypes (3))
               (columnName "flat_rate" primitiveTypes (1)) (columnName "valid_from" primitiveTypes (2))
               (columnName "sub accounts org id" primitiveTypes (1)) (columnName "billing_address" primitiveTypes (3))
               (columnName "account_owner" primitiveTypes (3)) (columnName "pay_cycle" primitiveTypes (3))
               (columnName "hourly_overage" primitiveTypes (1)) (columnName "expired_status" primitiveTypes (4))
               (columnName "terms" primitiveTypes (3)) (columnName "street" primitiveTypes (3))
               (columnName "valid_to" primitiveTypes (2)) (columnName "is_parent_or_child_account" primitiveTypes (4))
               (columnName "billing_email" primitiveTypes (3)) (columnName "min_servers" primitiveTypes (1))
               (columnName "conversion_date" primitiveTypes (2)) (columnName "customer_tier" primitiveTypes (1))
               (columnName "monthly_overage" primitiveTypes (1)) (columnName "state" primitiveTypes (3))
               (columnName "org_name" primitiveTypes (3)) (columnName "zip" primitiveTypes (1)) (columnName "po_num" primitiveTypes (3))
               (columnName "Unnamed 33" primitiveTypes (-1)) (columnName "pay_method" primitiveTypes (3))
               (columnName "price_per_server" primitiveTypes (1)) (columnName "custom_metrics" primitiveTypes (3))
               (columnName "auto_renew" primitiveTypes (4)) (columnName "org_id" primitiveTypes (1))
               (columnName "parent_account_id" primitiveTypes (1)) (columnName "is_valid" primitiveTypes (4))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "if value of terms is Committed then price_per_server otherwise 0 + if value of terms is Standard then price_per_server times min_servers otherwise 0"))
                   symbolics (map cadr col))))

(define (test18)
  (let* ((col '((columnName "parent_name" primitiveTypes (3)) (columnName "country" primitiveTypes (3))
               (columnName "city" primitiveTypes (3))
               (columnName "billing_contact" primitiveTypes (3))
               (columnName "flat_rate" primitiveTypes (1)) (columnName "valid_from" primitiveTypes (2))
               (columnName "sub accounts org id" primitiveTypes (1)) (columnName "billing_address" primitiveTypes (3))
               (columnName "account_owner" primitiveTypes (3)) (columnName "pay_cycle" primitiveTypes (3))
               (columnName "hourly_overage" primitiveTypes (1)) (columnName "expired_status" primitiveTypes (4))
               (columnName "terms" primitiveTypes (3)) (columnName "street" primitiveTypes (3))
               (columnName "valid_to" primitiveTypes (2)) (columnName "is_parent_or_child_account" primitiveTypes (4))
               (columnName "billing_email" primitiveTypes (3)) (columnName "min_servers" primitiveTypes (1))
               (columnName "conversion_date" primitiveTypes (2)) (columnName "customer_tier" primitiveTypes (1))
               (columnName "monthly_overage" primitiveTypes (1)) (columnName "state" primitiveTypes (3))
               (columnName "org_name" primitiveTypes (3)) (columnName "zip" primitiveTypes (1)) (columnName "po_num" primitiveTypes (3))
               (columnName "Unnamed 33" primitiveTypes (-1)) (columnName "pay_method" primitiveTypes (3))
               (columnName "price_per_server" primitiveTypes (1)) (columnName "custom_metrics" primitiveTypes (3))
               (columnName "auto_renew" primitiveTypes (4)) (columnName "org_id" primitiveTypes (1))
               (columnName "parent_account_id" primitiveTypes (1)) (columnName "is_valid" primitiveTypes (4))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "terms = Committed price_per_server terms = Standard price_per_server * min_servers"))
                   symbolics (map cadr col))))

(define (test19)
  (let* ((col '((columnName "parent_name" primitiveTypes (3)) (columnName "country" primitiveTypes (3))
               (columnName "city" primitiveTypes (3))
               (columnName "billing_contact" primitiveTypes (3))
               (columnName "flat_rate" primitiveTypes (1)) (columnName "valid_from" primitiveTypes (2))
               (columnName "sub accounts org id" primitiveTypes (1)) (columnName "billing_address" primitiveTypes (3))
               (columnName "account_owner" primitiveTypes (3)) (columnName "pay_cycle" primitiveTypes (3))
               (columnName "hourly_overage" primitiveTypes (1)) (columnName "expired_status" primitiveTypes (4))
               (columnName "terms" primitiveTypes (3)) (columnName "street" primitiveTypes (3))
               (columnName "valid_to" primitiveTypes (2)) (columnName "is_parent_or_child_account" primitiveTypes (4))
               (columnName "billing_email" primitiveTypes (3)) (columnName "min_servers" primitiveTypes (1))
               (columnName "conversion_date" primitiveTypes (2)) (columnName "customer_tier" primitiveTypes (1))
               (columnName "monthly_overage" primitiveTypes (1)) (columnName "state" primitiveTypes (3))
               (columnName "org_name" primitiveTypes (3)) (columnName "zip" primitiveTypes (1)) (columnName "po_num" primitiveTypes (3))
               (columnName "Unnamed 33" primitiveTypes (-1)) (columnName "pay_method" primitiveTypes (3))
               (columnName "price_per_server" primitiveTypes (1)) (columnName "custom_metrics" primitiveTypes (3))
               (columnName "auto_renew" primitiveTypes (4)) (columnName "org_id" primitiveTypes (1))
               (columnName "parent_account_id" primitiveTypes (1)) (columnName "is_valid" primitiveTypes (4))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "if terms = Committed then price_per_server * min_servers else flat_rate"))
                   symbolics (map cadr col))))

(define (test20)
  (let* ((col '((columnName "parent_name" primitiveTypes (3)) (columnName "country" primitiveTypes (3))
               (columnName "city" primitiveTypes (3))
               (columnName "billing_contact" primitiveTypes (3))
               (columnName "flat_rate" primitiveTypes (1)) (columnName "valid_from" primitiveTypes (2))
               (columnName "sub accounts org id" primitiveTypes (1)) (columnName "billing_address" primitiveTypes (3))
               (columnName "account_owner" primitiveTypes (3)) (columnName "pay_cycle" primitiveTypes (3))
               (columnName "hourly_overage" primitiveTypes (1)) (columnName "expired_status" primitiveTypes (4))
               (columnName "terms" primitiveTypes (3)) (columnName "street" primitiveTypes (3))
               (columnName "valid_to" primitiveTypes (2)) (columnName "is_parent_or_child_account" primitiveTypes (4))
               (columnName "billing_email" primitiveTypes (3)) (columnName "min_servers" primitiveTypes (1))
               (columnName "conversion_date" primitiveTypes (2)) (columnName "customer_tier" primitiveTypes (1))
               (columnName "monthly_overage" primitiveTypes (1)) (columnName "state" primitiveTypes (3))
               (columnName "org_name" primitiveTypes (3)) (columnName "zip" primitiveTypes (1)) (columnName "po_num" primitiveTypes (3))
               (columnName "Unnamed 33" primitiveTypes (-1)) (columnName "pay_method" primitiveTypes (3))
               (columnName "price_per_server" primitiveTypes (1)) (columnName "custom_metrics" primitiveTypes (3))
               (columnName "auto_renew" primitiveTypes (4)) (columnName "org_id" primitiveTypes (1))
               (columnName "parent_account_id" primitiveTypes (1)) (columnName "is_valid" primitiveTypes (4))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "average if terms = Committed then price_per_server * min_servers else flat_rate"))
                   symbolics (map cadr col))))

(define (test21)
  (let* ((col '((columnName "col1" primitiveTypes (1)) (columnName "col2" primitiveTypes (1)) (columnName "col3" primitiveTypes (1))(columnName "col4" primitiveTypes (1))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "if col4=4 if col2=2 then 4 else col3"))
                   symbolics (map cadr col))))

(define (test22)
  (let* ((col '((columnName "col1" primitiveTypes (1)) (columnName "col2" primitiveTypes (1)) (columnName "col3" primitiveTypes (1))))
         (symbolics (parse-column-metadata col)))
            (generate-data (lex (open-input-string "if col1=4 then if col2=2 then 4 else col3"))
                   symbolics (map cadr col))))

(define (test23)
  (let* ((col '((columnName "Hourly_overage" primitiveTypes (1)) (columnName "Is_Valid" primitiveTypes (4)) (columnName "Min servers" primitiveTypes (1)) (columnName "Notes" primitiveTypes (3)) (columnName "Pay_Cycle" primitiveTypes (3)) (columnName "Pay_Method" primitiveTypes (3)) (columnName "Price_Per_Server" primitiveTypes (1)) (columnName "Terms" primitiveTypes (3)) (columnName "Valid_From" primitiveTypes (2)) (columnName "Valid_To" primitiveTypes (2)) (columnName "agent_first_count" primitiveTypes (1)) (columnName "agent_hwm" primitiveTypes (1)) (columnName "agent_last_count" primitiveTypes (1)) (columnName "agent_lwm" primitiveTypes (1)) (columnName "average" primitiveTypes (1)) (columnName "aws_lwm" primitiveTypes (1)) (columnName "aws_first_count" primitiveTypes (1)) (columnName "aws_hwm" primitiveTypes (1)) (columnName "aws_last_count" primitiveTypes (1)) (columnName "elapsed_hours" primitiveTypes (1)) (columnName "first_count" primitiveTypes (1)) (columnName "first_hour" primitiveTypes (2)) (columnName "hwm" primitiveTypes (1)) (columnName "last_count" primitiveTypes (1)) (columnName "last_hour" primitiveTypes (2)) (columnName "lwm" primitiveTypes (1)) (columnName "server_hours" primitiveTypes (1)) (columnName "std_dev" primitiveTypes (1)) (columnName "top13" primitiveTypes (1)) (columnName "top25" primitiveTypes (1)) (columnName "top95p" primitiveTypes (1)) (columnName "top99p" primitiveTypes (1)) (columnName "std_plan_billable_hours" primitiveTypes (1)) (columnName "MRR" primitiveTypes (1))))
         (symbolics (parse-column-metadata col)))
    (generate-data (lex (open-input-string "if Terms is Committed and Hourly_overage is not blank then Hourly_overage else 0 else 99"))
                   symbolics (map cadr col))))

(define (test24)
  (let* ((col '((columnName "Hourly overage" primitiveTypes (1)) (columnName "Is_Valid" primitiveTypes (4)) (columnName "Min servers" primitiveTypes (1)) (columnName "Notes" primitiveTypes (3)) (columnName "Pay_Cycle" primitiveTypes (3)) (columnName "Pay_Method" primitiveTypes (3)) (columnName "Price_Per_Server" primitiveTypes (1)) (columnName "Terms" primitiveTypes (3)) (columnName "Valid_From" primitiveTypes (2)) (columnName "Valid_To" primitiveTypes (2)) (columnName "agent_first_count" primitiveTypes (1)) (columnName "agent_hwm" primitiveTypes (1)) (columnName "agent_last_count" primitiveTypes (1)) (columnName "agent_lwm" primitiveTypes (1)) (columnName "average" primitiveTypes (1)) (columnName "aws_lwm" primitiveTypes (1)) (columnName "aws_first_count" primitiveTypes (1)) (columnName "aws_hwm" primitiveTypes (1)) (columnName "aws_last_count" primitiveTypes (1)) (columnName "elapsed_hours" primitiveTypes (1)) (columnName "first_count" primitiveTypes (1)) (columnName "first_hour" primitiveTypes (2)) (columnName "hwm" primitiveTypes (1)) (columnName "last_count" primitiveTypes (1)) (columnName "last_hour" primitiveTypes (2)) (columnName "lwm" primitiveTypes (1)) (columnName "server_hours" primitiveTypes (1)) (columnName "std_dev" primitiveTypes (1)) (columnName "top13" primitiveTypes (1)) (columnName "top25" primitiveTypes (1)) (columnName "top95p" primitiveTypes (1)) (columnName "top99p" primitiveTypes (1)) (columnName "std_plan_billable_hours" primitiveTypes (1)) (columnName "MRR" primitiveTypes (1))))
         (symbolics (parse-column-metadata col)))
    (generate-data (lex (open-input-string "if Terms=Committed if 'Hourly overage' is not blank then else 5"))
                   symbolics (map cadr col))))

(define (test25)
  (let* ((col
          '((columnName "Hourly overage" primitiveTypes (1))
            (columnName "Monthly overage" primitiveTypes (1))(columnName "Is_Valid" primitiveTypes (4)) (columnName "Min servers" primitiveTypes (1)) (columnName "Notes" primitiveTypes (3)) (columnName "Pay_Cycle" primitiveTypes (3))
            (columnName "Pay_Method" primitiveTypes (3)) (columnName "Price Per Server" primitiveTypes (1)) (columnName "Terms" primitiveTypes (3)) (columnName "Valid_From" primitiveTypes (2)) (columnName "Valid_To" primitiveTypes (2)) (columnName "agent_first_count" primitiveTypes (1)) (columnName "agent_hwm" primitiveTypes (1)) (columnName "agent_last_count" primitiveTypes (1)) (columnName "agent_lwm" primitiveTypes (1)) (columnName "average" primitiveTypes (1)) (columnName "aws_lwm" primitiveTypes (1)) (columnName "aws_first_count" primitiveTypes (1)) (columnName "aws_hwm" primitiveTypes (1)) (columnName "aws_last_count" primitiveTypes (1)) (columnName "elapsed_hours" primitiveTypes (1)) (columnName "first_count" primitiveTypes (1)) (columnName "first_hour" primitiveTypes (2)) (columnName "hwm" primitiveTypes (1)) (columnName "last_count" primitiveTypes (1)) (columnName "last_hour" primitiveTypes (2)) (columnName "lwm" primitiveTypes (1)) (columnName "server_hours" primitiveTypes (1)) (columnName "std_dev" primitiveTypes (1)) (columnName "top13" primitiveTypes (1)) (columnName "top25" primitiveTypes (1)) (columnName "top95p" primitiveTypes (1)) (columnName "top99p" primitiveTypes (1)) (columnName "std_plan_billable_hours" primitiveTypes (1)) (columnName "MRR" primitiveTypes (1))))
         (symbolics (parse-column-metadata col)))
    (let* ((text (lex (open-input-string "if Terms=Committed then 'Price Per Server' *  'Min servers' otherwise 0 otherwise if Terms=Standard then top99p * 'Price Per Server' plus 'Monthly overage' otherwise 0")))
           (table (generate-data text symbolics (map cadr col)))
           (header '("Terms" "Price Per Server" "Min servers" "top99p" "Monthly overage"))
           (rows (cdr table))
           (inputstr (map (lambda(row) (take row 5)) rows))
           (outputstr (map (lambda(row) (list-ref row 5)) rows))
           (syb (list (val (make-col-name "Terms") string?) (val (make-col-name "Price Per Server") integer?)
                (val (make-col-name "Min servers") integer?) (val (make-col-name "top99p") integer?) (val (make-col-name "Monthly overage") integer?))))
      (println syb)
      (println inputstr)
      (println outputstr)
      (apply analyze-custom text outputstr header syb inputstr))))

(define (test26)
  (let* ((col
          '((columnName "Hourly overage" primitiveTypes (1))
            (columnName "Monthly overage" primitiveTypes (1))(columnName "Is_Valid" primitiveTypes (4)) (columnName "Min servers" primitiveTypes (1)) (columnName "Notes" primitiveTypes (3)) (columnName "Pay_Cycle" primitiveTypes (3))
            (columnName "Pay_Method" primitiveTypes (3)) (columnName "Price Per Server" primitiveTypes (1)) (columnName "Terms" primitiveTypes (3)) (columnName "Valid_From" primitiveTypes (2)) (columnName "Valid_To" primitiveTypes (2)) (columnName "agent_first_count" primitiveTypes (1)) (columnName "agent_hwm" primitiveTypes (1)) (columnName "agent_last_count" primitiveTypes (1)) (columnName "agent_lwm" primitiveTypes (1)) (columnName "average" primitiveTypes (1)) (columnName "aws_lwm" primitiveTypes (1)) (columnName "aws_first_count" primitiveTypes (1)) (columnName "aws_hwm" primitiveTypes (1)) (columnName "aws_last_count" primitiveTypes (1)) (columnName "elapsed_hours" primitiveTypes (1)) (columnName "first_count" primitiveTypes (1)) (columnName "first_hour" primitiveTypes (2)) (columnName "hwm" primitiveTypes (1)) (columnName "last_count" primitiveTypes (1)) (columnName "last_hour" primitiveTypes (2)) (columnName "lwm" primitiveTypes (1)) (columnName "server_hours" primitiveTypes (1)) (columnName "std_dev" primitiveTypes (1)) (columnName "top13" primitiveTypes (1)) (columnName "top25" primitiveTypes (1)) (columnName "top95p" primitiveTypes (1)) (columnName "top99p" primitiveTypes (1)) (columnName "std_plan_billable_hours" primitiveTypes (1)) (columnName "MRR" primitiveTypes (1))))
         (symbolics (parse-column-metadata col)))
    (let* ((text (lex (open-input-string "if Terms=Committed then 'Price Per Server' *  'Min servers' if Terms=Standard then top99p * 'Price Per Server' plus 'Monthly overage' otherwise 0")))
           (table (generate-data text symbolics (map cadr col)))
           (header '("Terms" "Price Per Server" "Min servers" "top99p" "Monthly overage"))
           (rows (cdr table))
           (inputstr (map (lambda(row) (take row 5)) rows))
           (outputstr (map (lambda(row) (list-ref row 5)) rows))
           (syb (list (val (make-col-name "Terms") string?) (val (make-col-name "Price Per Server") integer?)
                (val (make-col-name "Min servers") integer?) (val (make-col-name "top99p") integer?) (val (make-col-name "Monthly overage") integer?))))
      (println syb)
      (println inputstr)
      (println outputstr)
      (apply analyze-custom text outputstr header syb inputstr))))
 